#include <bewis.hpp>

using namespace std;
using namespace cv;

char buffer[1024];
const string WinTitle = "BeWIS - BG Estimator";

// Colors
Scalar bgcolor = Scalar(106,117,181);
// Gui settings

void rgb2rgb(Mat in, Mat &out) {
    in.copyTo(out);
}

void rgb2lab(Mat in, Mat &out) {
    cvtColor(in, out, CV_BGR2Lab);
}

void rgb2hsv(Mat in, Mat &out) {
    cvtColor(in, out, CV_BGR2HSV);
}

void lab2rgb(Mat in, Mat &out) {
    cvtColor(in, out, CV_Lab2BGR);
}

void hsv2rgb(Mat in, Mat &out) {
    cvtColor(in, out, CV_HSV2BGR);
}

void rgb2gray(Mat in, Mat &out) {
    cvtColor(in, out, CV_BGR2GRAY);
}

void lab2gray(Mat in, Mat &out) {
    cvtColor(in, out, CV_Lab2BGR);
    cvtColor(out, out, CV_BGR2GRAY);
}

void hsv2gray(Mat in, Mat &out) {
    cvtColor(in, out, CV_HSV2BGR);
    cvtColor(out, out, CV_BGR2GRAY);
}

int getdir(string dir, vector<string> &files, string ext) {
    DIR *dp;
    struct dirent *dirp;
    int cnt=0;
    string fn;
    
    if((dp = opendir(dir.c_str())) == NULL) {
        cout << "Error(" << -1 << ") wrong dir " << dir << endl;
        return -1;
    }
    while ((dirp = readdir(dp)) != NULL) {
        if (dirp->d_name[0] != '.') {  /* ignore hidden files */
            fn = string(dirp->d_name);
            if(fn.substr(fn.find_last_of(".") + 1) == ext) {
                files.push_back(fn);
                cnt++;
            }
        }
    }
    closedir(dp);
    if (cnt == 0) {
        cout << "Error(" << -2 << ") empty dir " << dir << endl;
        return -2;
    }
    return cnt;
}

Mat& discretize(Mat& I, int dimTics) {
    // accept only char type matrices
    CV_Assert(I.depth() != sizeof(uchar));
    
    int channels = I.channels();
    
    int nRows = I.rows;
    int nCols = I.cols * channels;
    
    if (I.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }
    
    int i,j;
    uchar* p;
    for( i = 0; i < nRows; ++i)
    {
        p = I.ptr<uchar>(i);
        for ( j = 0; j < nCols; ++j)
        {
            p[j] = (unsigned char) ((p[j] / dimTics) * dimTics);
;
        }
    }
    return I;
}

void showImages(Mat &dispimg, list< pair < Mat, Rect > > imglist, list< pair < string, Point > > tlist) {
    int baseline;
    Size tsize = getTextSize("dummy",CV_FONT_HERSHEY_PLAIN,1.0,1,&baseline);
    for (std::list< pair < Mat, Rect > >::const_iterator it = imglist.begin(); it != imglist.end(); ++it) {
        (*it).first.copyTo(dispimg((*it).second));
    }
    for (std::list< pair < string, Point > >::const_iterator it = tlist.begin(); it != tlist.end(); ++it) {
        putText(dispimg,(*it).first,(*it).second,CV_FONT_HERSHEY_PLAIN,1.0,Scalar(255,255,255));
    }
    imshow(WinTitle,dispimg);
}

int main(int argc, char** argv) {
    // Parse commands globs
    DIR *dp, *op;   // input dir
    FILE *fp;
    int dcnt;
    vector<string> dlist = vector<string>();
    string videoname;
    double incr=1.0, decr=1.0;
    int err;
    int delta;
    bool outflag= false;
    
    // Graphics globs
    Mat frame, frame_orig; //current frame
    int frameidx = 0;
    Mat bgmodel, bgmodel_out; //fg/bg masks  generated by MOG2 method
    Mat frameYCrCb, bgmodelYCrCb; //fg/bg masks  generated by MOG2 method
    Mat tmpMask, deltaimg;
    Mat frameY[3], bgmodelY[3];
    list< pair < Mat, Rect > > imglist; // image/ROI list for display
    list< pair < string, Point > > titlelist; // image/ROI list for display
    void (*convert)(Mat, Mat &);
    void (*backconvert)(Mat, Mat &);
    string titleupleft, titleupright="BG Model", titledownleft="Diff |Input-BG|", titledownright="FG Detection";

    // Timing globs
    double fps, rfps, mfps=-2;
    struct timeval t1, t2;
    
    // Set Command Line Parser
    bool verboseFlag = false;
    bool erosionFlag = false; bool blurFlag = false; bool dilationFlag = false;
    bool reverseFlag = false;
    string indirname = ".";
    string outdirname = ".";
    string extArg = "png";
    string coding = "RGB";
    int nbit = 4, ntics = 256, learntime = 1, cachesize = 20;
    string policy = "1:1";
    double watermark = 0.0, uppermark = 50.0, thresh = 0.75;
    int selectthresh = 2;
    vector<string> args(argv + 1, argv + argc);
    for (vector<string>::iterator i = args.begin(); i != args.end(); ++i) {
        if (*i == "-h" || *i == "--help") {
            cout << "Syntax: bewis -i <indir>" << endl;
            cout << string(17, ' ') << "image input folder" << endl;
            cout << string(14, ' ') << "-o <outdir>, --outdir <outdir>" << endl;
            cout << string(17, ' ') << "BG output folder" << endl;
            cout << string(14, ' ') << "-m <RGB|Lab|HUV>, --mode <RGB|Lab|HUV>" << endl;
            cout << string(17, ' ') << "color mode (default: RGB)" << endl;
            cout << string(14, ' ') << "-p <int:int>, --policy <int:int>" << endl;
            cout << string(17, ' ') << "NN policy (default: 1:1)" << endl;
            cout << string(14, ' ') << "-x <png|jpg>, --extension <png|jpg>" << endl;
            cout << string(17, ' ') << "image format (default: png)" << endl;
            cout << string(14, ' ') << "-b <int>, --bits <int>" << endl;
            cout << string(17, ' ') << "NN bit resolution (default: 4)" << endl;
            cout << string(14, ' ') << "-z <int>, --scale <int>" << endl;
            cout << string(17, ' ') << "color discretization scale (default: 256)" << endl;
            cout << string(14, ' ') << "-t <double>, --threshold <double>" << endl;
            cout << string(17, ' ') << "NN threshold (default: 0.75)" << endl;
            cout << string(14, ' ') << "-u <double>, --uppermark <double>" << endl;
            cout << string(17, ' ') << "NN rams saturation limit (default: 50)" << endl;
            cout << string(14, ' ') << "-w <double>, --watermark <double>" << endl;
            cout << string(17, ' ') << "NN rams firing threshold (default: 0)" << endl;
            cout << string(14, ' ') << "-k <int>, --cap <int>" << endl;
            cout << string(17, ' ') << "color repetition time (default: 2)" << endl;
            cout << string(14, ' ') << "-l <int>, --learntime <int>" << endl;
            cout << string(17, ' ') << "pre-learning time (in no of frames) (default: 1)" << endl;
            cout << string(14, ' ') << "-h, --help" << endl;
            cout << string(17, ' ') << "display this help" << endl;
            cout << string(14, ' ') << "-v, --verbose" << endl;
            cout << string(17, ' ') << "display system and video configuration" << endl;
            cout << string(14, ' ') << "-r, --reverse" << endl;
            cout << string(17, ' ') << "process video also in reverse mode" << endl;
            return 0;
        } else if (*i == "-v" || *i == "--verbose") {
            verboseFlag = true;
        } else if (*i == "-r" || *i == "--reverse") {
            reverseFlag = true;
        } else if (*i == "-i" || *i == "--indir") {
            indirname = *++i;
            int pos;
            if ((pos = indirname.find_last_of("/\\")) == indirname.size() - 1) {
                indirname = indirname.substr(0,indirname.size()-1);
                pos = indirname.find_last_of("/\\");
            }
            videoname = indirname.substr(pos+1);
            if ((dp = opendir (indirname.c_str())) == NULL) {
                cerr << "Parse error: Could not open input dir" << endl;
                exit(-1);
            }
        } else if (*i == "-o" || *i == "--outdir") {
            outdirname = *++i;
            outflag = true;
            if ((op = opendir (outdirname.c_str())) == NULL) {
                cerr << "Parse error: Could not open output dir" << endl;
                exit(-1);
            }
        } else if (*i == "-m" || *i == "--mode") {
            coding = *++i;
        } else if (*i == "-k" || *i == "--cap") {
            selectthresh = atoi((*++i).c_str());
        } else if (*i == "-x" || *i == "--extension") {
            extArg = *++i;
            if (extArg != "jpg" && extArg != "png" ) {
                cerr << "Parse error: Argument: -x" << endl;
                cerr << string(13, ' ') << "Image extension must be png|jpg" << endl;
                exit(-1);
            }
        } else if (*i == "-b" || *i == "--bits") {
            nbit = atoi((*++i).c_str());
        } else if (*i == "-w" || *i == "--watermark") {
            watermark = (double)atof((*++i).c_str());
        } else if (*i == "-u" || *i == "--uppermark") {
            uppermark = (double)atof((*++i).c_str());
        } else if (*i == "-z" || *i == "--scale") {
            ntics = atoi((*++i).c_str());
        } else if (*i == "-l" || *i == "--learntime") {
            learntime = atoi((*++i).c_str());
        } else if (*i == "-t" || *i == "--threshold") {
            thresh = (double)atof((*++i).c_str());
        } else if (*i == "-p" || *i == "--policy") {
            policy = *++i;
            if ((err = parsePolicy(policy,incr,decr)) < 0) {
                cerr << "Parse error: Argument: -w" << endl;
                cerr << string(13, ' ') << "policy setting must be <int>:<int>" << endl;
                exit(-1);
            }
        } else {
            cout << "Parse error: wrong argument syntax" << endl;
            exit(-1);
        }
    }


    if ((dcnt = getdir(indirname.c_str(), dlist, extArg)) < 0) {
        cerr << "I/O Error: Empty input dir" << endl;
        exit(-1);
    }
    if (coding == "RGB") {
        convert = &rgb2rgb;
        backconvert = &rgb2rgb;
        titleupleft = "Input(RGB): ";
    } else if (coding == "Lab") {
        convert = &rgb2lab;
        backconvert = &lab2rgb;
        titleupleft = "Input(Lab): ";
    } else if (coding == "HSV") {
        convert = &rgb2hsv;
        backconvert = &hsv2rgb;
        titleupleft = "Input(HSV): ";
    } else {
        cerr << "Parse error: Argument: -m" << endl;
        cerr << string(13, ' ') << "Color space must be RGB|HSV|Lab" << endl;
        exit(-1);
    }
    delta = 256 / ntics;
    // Get firt frame
    frame_orig = imread(indirname + "/" + dlist[frameidx]);
    if(! frame_orig.data ) {
        cout << "Could not open read frame" << endl;
        exit(-1);
    }
    convert(frame_orig, frame);
    int w = frame.cols;
    int h = frame.rows;
    cout << "Processing Video (" << w << "x" << h << ")" << endl;

    Ptr<BackgroundSubtractorWIS> Subtractor;
    Subtractor = createBackgroundSubtractorWIS();
    Subtractor->set("noBits", nbit);
    Subtractor->set("noTics", ntics);
    Subtractor->set("trainIncr", incr);
    Subtractor->set("trainDecr", decr);
    Subtractor->set("cacheSize", cachesize);
    Subtractor->set("varWatermark", watermark);
    Subtractor->set("varThreshold", thresh);
    Subtractor->set("varUpWatermark", uppermark);
    Subtractor->set("selectThreshold", selectthresh);
    Subtractor->set("learningStage", learntime);
    Subtractor->initialize(frame.size(), frame.type());
    if (verboseFlag) {
        cout << left << setw(MAXWIDTH) << setfill(filler) << "I/O GRAPHICS PARAMS" << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Video Coding" << ": " << coding << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Input Directory" << ": " << indirname << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Video Name" << ": " << videoname << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Blur" << ": " << blurFlag << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Erosion" << ": " << erosionFlag << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Dilation" << ": " << dilationFlag << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Reverse" << ": " << reverseFlag << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "WISARD DETECTOR PARAMS" << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "noBits: " << Subtractor->getInt("noBits") << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "noTics: " << Subtractor->getInt("noTics") << "(" << Subtractor->getInt("dimTics") << ")" << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "noRams: " << Subtractor->getInt("noRams") <<  endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Train Policy: " << Subtractor->getDouble("trainIncr") << ":" << Subtractor->getDouble("trainDecr") <<  endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Classification Thresh: " << Subtractor->getDouble("varThreshold") << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Selection Thresh: " << Subtractor->getInt("selectThreshold") << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Watermark: " << Subtractor->getDouble("varWatermark") << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Uppermark: " << Subtractor->getDouble("varUpWatermark") << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "LearningStage: " << Subtractor->getInt("learningStage") << endl;
        cout << left << setw(MAXWIDTH) << setfill(filler) << "Cachesize: " << Subtractor->getInt("cacheSize") << endl;
    }
    
    // Open Video Stream and get properties
    fps = 30;
    mfps = (int)fps;
    // Create output display and its geometry
    int hskip = 16, wskip = 4;
    int dcols = 3;
    //Mat outFrame(2*h+2*hskip+wskip,w*dcols+(dcols+1)*wskip,CV_8UC3,bgcolor);
    Mat outFrame(h+hskip+wskip,w*dcols+(dcols+1)*wskip,CV_8UC3,bgcolor);
    
    // create window an put icons
    cvNamedWindow(WinTitle.c_str(),CV_WINDOW_AUTOSIZE);
    
    int cnt = 0;
    // video processing loop
    int plus = 1;
    
    while (frameidx >= 0 and frameidx < dcnt) {
        gettimeofday(&t1,NULL);
        frame_orig = imread(indirname + "/" + dlist[frameidx]);  //get one frame form video
        if(! frame_orig.data ) {
            cout << "Could not open read frame" << endl;
            exit(-1);
        }
        if (blurFlag) blur(frame,frame,Size(3,3));
        convert(frame_orig, frame);

        Subtractor->apply(frame, tmpMask);  // update Background Model (training)
        Subtractor->getBackgroundImage(bgmodel); // get Background Model
        
        if (erosionFlag) { erode(tmpMask,tmpMask,cv::Mat()); }
        if (dilationFlag){ dilate(tmpMask,tmpMask,cv::Mat());}
        
        if (waitKey(30) >= 0)
            break;
        gettimeofday(&t2,NULL);
        rfps = (int)(1.0 / ((double) (t2.tv_usec - t1.tv_usec)/1000000 + (double) (t2.tv_sec - t1.tv_sec)));
        if (mfps != rfps && frameidx % 5 == 0) mfps = rfps;
        
        // Back convert for display
        backconvert(frame,frame);
        backconvert(bgmodel, bgmodel);
        // difference by luminance (Ycrcb)
        cvtColor(frame,frameYCrCb,CV_BGR2YCrCb);
        cvtColor(bgmodel,bgmodelYCrCb,CV_BGR2YCrCb);
        split(frameYCrCb,frameY);
        split(bgmodelYCrCb,bgmodelY);
        absdiff(frameY[0],bgmodelY[0],deltaimg);
        threshold(deltaimg,deltaimg, 20, 255, CV_THRESH_BINARY);
        cvtColor(deltaimg,deltaimg,CV_GRAY2BGR,3);
        
        // build up disaply
        outFrame.setTo(bgcolor);
        imglist.clear();
        titlelist.clear();
        imglist.push_back(make_pair(frame,Rect(Point(wskip,hskip-2),Size(w,h))));  // original frame (Up left)
        titlelist.push_back(make_pair(titleupleft + format("%05d",frameidx),Point(wskip,hskip-5)));
        imglist.push_back(make_pair(bgmodel,Rect(Point(wskip*2+w,hskip-2),Size(w,h))));  // bgmodel (Up right)
        titlelist.push_back(make_pair(titleupright,Point(wskip*2+w,hskip-5)));
        imglist.push_back(make_pair(deltaimg,Rect(Point(wskip*3+2*w,hskip-2),Size(w,h))));  // bgmodel (Up right)
        titlelist.push_back(make_pair(titledownleft,Point(wskip*3+2*w,hskip-5)));
        showImages(outFrame, imglist, titlelist);
        waitKey(1);
        frameidx += plus;
        if (reverseFlag and frameidx == dcnt) { plus = -1; frameidx--; frameidx--; };  // reverse
    }
    if (outflag) imwrite(outdirname + "/BC_" + videoname + ".png", bgmodel);
}


